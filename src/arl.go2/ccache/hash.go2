package ccache

import (
	"fmt"
	"hash/maphash"
)

// castTo casts t from interface{} to T.
func castTo(type T)(t interface{}) T { return t.(T) }

// hashFunction returns a hash function specific for K
func hashFunction(type K comparable)() (func(*maphash.Hash, K) uint64) {
	var v K
	switch (interface{})(v).(type) {
	case int:
		return castTo(func(*maphash.Hash, K) uint64)(IntHash)
	case int64:
		return castTo(func(*maphash.Hash, K) uint64)(Int64Hash)
	case string:
		return castTo(func(*maphash.Hash, K) uint64)(StringHash)
	default:
		panic(fmt.Sprintf("hash function unimplemented for type %T", v))
	}
}

func IntHash(mh *maphash.Hash, i int) uint64 {
	b := []byte{byte(0xff & i), byte(0xff & (i >> 8)),
		byte(0xff & (i >> 16)), byte(0xff & (i >> 24)),
	}

	mh.Reset()
	mh.Write(b)

	return mh.Sum64()
}

func Int64Hash(mh *maphash.Hash, i int64) uint64 {
	b := []byte{byte(0xff & i), byte(0xff & (i >> 8)),
		byte(0xff & (i >> 16)), byte(0xff & (i >> 24)),
	}

	mh.Reset()
	mh.Write(b)

	return mh.Sum64()
}

func StringHash(mh *maphash.Hash, k string) uint64 {
	mh.Reset()
	mh.WriteString(k)

	return mh.Sum64()
}
