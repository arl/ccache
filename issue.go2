package main

import "fmt"

// entry stores cached entry key and value.
type entry(type K comparable, V any) struct {
	key   K
	value V

	// accessed is the number of nanoseconds elapsed between the cache epoch and the last time the key was accessed.
	accessed uint64
	// updated is the number of nanoseconds elapsed between the cache epoch and the last time the key was updated.
	updated uint64

	// hash of this key
	hash uint64
}

// any is a convenient type bounds.
type any interface{}

// policy is a cache eviction policy.
type policy(type K comparable, V any) interface {
	init(cache *Cache(K, V), maximumSize int)
	add(*entry(K, V)) *entry(K, V)
	del(*entry(K, V)) *entry(K, V)
	add(*entry(K, V))
}

// LRU is a least-frequently-used policy.
type LRU(type K comparable, V any) struct{}

func (p *LRU) init(cache *Cache(K, V), maximumSize int) {

}
func (p *LRU) add(*entry(K, V)) *entry(K, V) {

}
func (p *LRU) del(*entry(K, V)) *entry(K, V) {

}
func (p *LRU) add(*entry(K, V)) {

}

type Cache(type K comparable, V any) struct {
	policy policy(K, V)
}

func NewCache(type K comparable, V any)(maxkeys uint64, p policy(K, V)) Cache(K, V) {
	return Cache(K, V){
		policy: p,
	}
}

func main() {
	lru := LRU(int, string){}
	c := NewCache(256, lru)
	fmt.Println(lru, c)
}
